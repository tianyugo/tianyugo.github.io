---

layout: post
title:  "Spring学习笔记"
date:   2020年5月22日 10点33分        
categories: me 
tags: code
excerpt: Spring IOC AOP
mathjax: true
author: Sky
---

* content
{:toc}
# Spring

## Spring 相关概念

- 开源、轻量级框架

- 核心：

  1. AOP：面向切面

     扩展代码不是修改代码实现

  2. IOC：控制反转

     对象交给Spring配置创建

- JavaEE一站式

  三层结构中每一层提供不同的解决技术

  1. web层：SpringMVC
  2. service层：Spring的IOC
  3. dao层：Spring的jdbcTemplate

## IOC

> 把对象的创建交给Spring进行管理

### 底层原理

- 底层使用的技术
  1. xml配置文件
  2. dom4j解析xml
  3. 工厂设计模式
  4. 反射

- 发展过程：

  1）原来的方式:

  ~~~java
  public class User{
      public void add(){
          //......
      }
  }
  
  //在servlet钟如果要使用User类的方法
  public class Servlet{
      User user = new User();
      user.add();
  }
  
  ####存在问题（耦合度）：User 的方法修改了名字，Servlet也要修改####
  ~~~

  2）使用工厂模式解耦合

  ~~~~java
  public class UserService{
      public void add(){
          //......
      }
  }
  
  //在servlet钟如果要使用User类的方法
  public class UserServlet{
      UserService  s = Factory.getService();
      s.add();   
  }
  
  
  //解决方法：创建工厂类
  public class Factory{
      //提供返回UserSercive对象的方法
      public static UserService getService(){
          return new UserService();
      }
  }
  ####仍存在工厂给和servlet的耦合：工厂里仍要new
  ~~~~

  #### 3）IOC：高内聚、低耦合

  ~~~java
  public class UserService{
      public void add(){
          ......
      }
  }
  
  public class UserServlet{
      //直接调用factory的静态方法：实现在下一节 
      //不用再new了
      UserFactory.getService();
  }
  ~~~

  ### 实现过程

  一、创建xml配置文件

  ~~~xml
  <bean id="userService" class="类路径（com.it.UserService）">
  ~~~

  二、创建工厂类+使用dom4j解析配置文件+反射

  ~~~java
  public class UserFactory{
      //提供返回UserSercive对象的方法
      public static UserService getService(){
          //1.使用dom4j解析xml
          //根据id值得到class路径
          String classValue = "class属性值";
          //2.使用反射创建类的对象
          Class clazz = CLass.forName(classValue);
          UserService s = clazz.newIntance();
          return s;
      }
  }
  ~~~

  

  **补充：**

  **源码阅读**

  

### 配置文件方式：创建

1. 配置文件

   1）默认构造函数创建（最常用）

   ~~~xml
   <!--引入约束内容——>
   <bean id="userService" class="类路径（com.it.UserService）"></bean>
   ~~~

   > 这种xml配置方法，使用的是默认的无参构造，没有无参构造函数获取Bean时会报错。

   ~~~java
   public void testUser(){
       //1.加载Spring配置文件并创建配置内容对象
       ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");//s
       rc/bean.xml
       //2.得到配置中想要的对象
       User user = (User) context.getBean("user");//id
       //
       user.add();
   }
   ~~~

   2）静态工厂

   ~~~xml
   <!--引入约束内容——>
   <bean id="bean2" class="工厂类的路径（com.it.Bean2Factory）" factory-method="getBean2"/></bean>
   ~~~

   工厂类

   ~~~java
   public class Bean2Factory{
       //静态方法，返回Bean2对象
       public static Bean2 getBean2(){
           return new Bean2();
       }
   }
   ~~~

   ~~~java
   public void testBean2(){
       //1.加载Spring配置文件并创建配置内容对象
       ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");//s
       rc/bean.xml
       //2.得到配置中想要的对象
       Bean2 bena2= (Bean2) context.getBean("bean2");//id
       
   }
   ~~~

   3）实例工厂（实例方法）

   配置文件中，再加上工厂对象

   

2. 注解方式





#### Bean标签的常用属性

1. id：起的名字。引用时id

   使用中根据id值配置对象

2. class：创建对象的类的全路径

   

3. name：同id，但可以包含符号，遗留问题，之前有框架用name

   忽略吧

4. scope：Bean的作用范围

   **singleton：单例**

   **prototype：多例**

   request

   session

   globalSession





### 配置文件方式：Bean属性注入

1. 不用框架

   不用Spring，可以使用    `有参构造`  、 `set方法`、`接口注入(略)`

2. Spring框架

   1）set方法（常用）

   > 有set方法后，可以读取xml文件，创建类时并注入property属性值

   Book类

   ~~~java
   class Book{
       private String bookName；
       set();//简略版 
       
   }
   ~~~

   测试

   ~~~java
   public void testBean2(){
       //1.加载Spring配置文件并创建配置内容对象
       ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
       //2.得到配置中想要的对象
       Book book= (Book) context.getBean("book");//id
       syso(book.bookName);//新华字典
   }
   ~~~

   bean.xml：

   ~~~xml
   <bean id="book" class="">
       <!-- name：类中定义的属性的名称
    		 value:设置的属性值
   	-->
       <property name="bookName" value="新华字典"></property>
   </bean>
   ~~~

   2）有参构造注入

   xml：

   ~~~xml
   <bean id="userService" class="类路径（com.it.UserService）">
       <constructor-arg name="username" value= "小王"></constructor-arg>
   </bean>
   ~~~

3. **实际使用：set方法-注入对象**

   > service中使用dao对象

    Service类

   ~~~java
   public class UserService{
       //UserDao userDao = new UserDao();
       
       //1.定义dao对象属性
       private UserDao userDao;
       //2.生成属性set方法
       public void setUserDao(UserDao userDao){
           this.userDao = userDao;
       }
       
       
       public void add(){
           //使用
           userDao.add();
       }
   }
   ~~~

   Dao类

   ~~~Java
   public class UserDao{
       
      add(){
          
      }
       
   }
   ~~~

   xml

   ~~~xml
   <bean id="userService" class="x.x.UserService">
        <!--注入Dao对象
    		 name：类中定义的属性的名称
    		 ref：引用：应与bean-id相同
   	-->
       <property name="userDao" ref="userDao"></property>
   </bean>
   
   <bean id="userDao" class="x.x.UserDao"></bean>
   ~~~

   测试

   ~~~java
   public void testBean2(){
       //1.加载Spring配置文件并创建配置内容对象
       ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
       //2.得到配置中想要的对象
       UserService sk = (UserService) context.getBean("userService");//id
       sk.add();
       
   }
   ~~~

   

   



### IOC和DI区别

IOC：控制反转

DI：依赖注入





把加载配置文件和创建对象的过程，在服务器启动时就完成

    //1.加载Spring配置文件并创建配置内容对象
    ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");




### 注解方式：创建+属性注入

xml：开启注解扫描：对包扫描. 把包上级位置加入，则包含所有包

~~~xml
<!-- 开启注解扫描-->
<context:component-scan base-package="cn.it"></context>
~~~

#### 创建对象

注解：

> ```java
> @Component(value="叫啥") //value可以不写 //相当于xml中加 <bean id="叫啥" class=""></bean>
> 	@Controller	——	web层
> 	@Service	——  业务层
> 	@Repository ——  持久层
> ```

> ~~~java
> @Scope(value="prototype")//多实例
> ~~~



User类

~~~java
@Component("user") //<bean id="user" class=""></bean>
public class User{
   
   add(){
      
   }    
}
~~~

测试

~~~java
@Test
public void test(){
    ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
    User user = (User) context.getBean("user");
}
~~~



#### 属性注入

> @AutoWired     --自动注入，且不需要再写set方法
>
> ​	通过类找，跟id没关系

 Service类

~~~java
@Service("userService")
public class UserService{
     
    @AutoWired
    private UserDao userDao;
   //不需要set方法了
    
    public void add(){
        userDao.add();
    }
}
~~~

Dao类

~~~Java
@Repository("userDao")
public class UserDao{
 
   add(){      
   }    
}
~~~



> @Resource(name="userDao")   --指定对象
>





### Spring Bean管理结合方式

> 创建用配置文件
>
> 属性注入用注解

xml

~~~xml
<bean id="userService" class="类路径（com.it.UserService）"></bean>
<bean id="userDao" class="类路径（com.it.UserDao）"></bean>
~~~

使用

~~~java
class userService{
	@Resource(name="userDao")   
	UserDao userDao;
}
~~~



## AOP

### 概念

面向切面编程

横向抽取机制，取代了纵向继承重复性的代码（性能监视、事务管理、安全检查、缓存）

实现了：扩展功能不修改源代码



### 发展过程

原来：

~~~java
public class User{
    public void add(){
        //。。。
    }
}
~~~

想要扩展：

> 添加数据之后，添加日志功能，记录添加时刻

~~~java
public class User{
    public void add(){
        //
        //扩展功能
    }
}
~~~

纵向解决：没用

> 继承：super.addlog();

aop解决：横向抽取

> 底层：使用动态代理



1. 有接口情况：jdk动态代理

   ~~~java
   public interface Dao{
       public void add(){
       }
   }
   
   public class DaoImpl implements Dao{
       public void add(){
           //添加       
       }
   }
   ~~~

   > 动态代理方式，创建接口实现类代理对象

   创建和DaoLmpl类的平级对象

   实现和这个类相同的功能

   

2. 没有接口：Cglib动态代理

   ~~~java
   public class User{
       public void add(){
           //添加       
       }
   }
   ~~~

   > 动态代理实现思路

   创建User类的子类的代理对象

   在子类里条用父类的方法完成增强

![v2-e777957e808c92fefcbcbec3945a2f91_r](C:\Users\Sty\Pictures\Saved Pictures\v2-e777957e808c92fefcbcbec3945a2f91_r.jpg)

### 术语

> Pointcut 切入点：实际增强的方法 
>
> Advice 增强/通知：扩展的逻辑，添加的功能；通知：前置、后置、异常、最终：后置之后、环绕
>
> Aspect 切面：增强加到具体方法上的过程

Joinpoint 连接点：类里面哪些方法可以增强

Introduction 引介：动态添加方法和属性

Target 目标对象：要增强的类

Weaving 织入：增强用到target的过程 

Proxy 代理：AOP织入增强后，产生了一个结果代理类

~~~java
public class User{
    public void add();
        	update();
    		delete();  
}
~~~



### Spring的AOP操作

> 在Spring里进行aop操作，使用AspectJ框架实现。Spring2.0添加

用AspectJ实现aop的两种方式

- xml配置
- 注解





































2020年4月8日 10点38分

联系我：shentianyu18@163.com









  


